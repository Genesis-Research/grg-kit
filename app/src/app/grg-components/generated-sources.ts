/**
 * AUTO-GENERATED FILE - DO NOT EDIT DIRECTLY
 * Generated by: scripts/generate-sources.js
 * Run: pnpm generate:blocks
 * 
 * Source of truth: app/libs/grg-ui
 */

export const fileUploadSource = `/**
 * FileUpload Component
 *
 * A flexible file upload component for Angular applications.
 *
 * Copy this file to your project and customize as needed.
 *
 * Dependencies:
 * - @spartan-ng/helm (UI components)
 * - class-variance-authority (styling variants)
 * - clsx (class utilities)
 *
 * Usage:
 * 1. Copy this file to your project (e.g., libs/ui/file-upload/)
 * 2. Add path mapping in tsconfig.json:
 *    "@grg-kit/ui/file-upload": ["./libs/ui/file-upload/file-upload.component.ts"]
 * 3. Import GrgFileUploadImports in your component
 */

import {
	Component,
	ElementRef,
	Pipe,
	PipeTransform,
	computed,
	input,
	model,
	output,
	signal,
	viewChild,
} from '@angular/core';
import { hlm } from '@spartan-ng/helm/utils';
import { cva, type VariantProps } from 'class-variance-authority';
import { type ClassValue } from 'clsx';

export const fileIconVariants = cva(
	'flex items-center justify-center rounded-md shrink-0',
	{
		variants: {
			variant: {
				default: 'bg-muted text-muted-foreground',
				image: 'bg-blue-100 text-blue-600 dark:bg-blue-900/30 dark:text-blue-400',
				document: 'bg-orange-100 text-orange-600 dark:bg-orange-900/30 dark:text-orange-400',
				video: 'bg-purple-100 text-purple-600 dark:bg-purple-900/30 dark:text-purple-400',
				audio: 'bg-green-100 text-green-600 dark:bg-green-900/30 dark:text-green-400',
				archive: 'bg-yellow-100 text-yellow-600 dark:bg-yellow-900/30 dark:text-yellow-400',
			},
			size: {
				sm: 'h-8 w-8',
				md: 'h-10 w-10',
				lg: 'h-12 w-12',
			},
		},
		defaultVariants: {
			variant: 'default',
			size: 'md',
		},
	},
);

export type FileIconVariants = VariantProps<typeof fileIconVariants>;
export type FileIconVariant = 'default' | 'image' | 'document' | 'video' | 'audio' | 'archive';

@Component({
	selector: 'grg-file-icon',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	template: \`<ng-content />\`,
})
export class GrgFileIcon {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly variant = input<FileIconVariant>('default');
	public readonly size = input<'sm' | 'md' | 'lg'>('md');

	protected readonly _computedClass = computed(() =>
		hlm(
			fileIconVariants({
				variant: this.variant(),
				size: this.size(),
			}),
			this.userClass(),
		),
	);

	static getVariantFromMimeType(mimeType: string): FileIconVariant {
		if (mimeType.startsWith('image/')) return 'image';
		if (mimeType.startsWith('video/')) return 'video';
		if (mimeType.startsWith('audio/')) return 'audio';
		if (
			mimeType.includes('pdf') ||
			mimeType.includes('document') ||
			mimeType.includes('text')
		) {
			return 'document';
		}
		if (
			mimeType.includes('zip') ||
			mimeType.includes('rar') ||
			mimeType.includes('tar') ||
			mimeType.includes('gzip')
		) {
			return 'archive';
		}
		return 'default';
	}
}

@Component({
	selector: 'grg-file-info',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	template: \`<ng-content />\`,
})
export class GrgFileInfo {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('flex-1 min-w-0', this.userClass()),
	);
}

@Component({
	selector: 'grg-file-list-item',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		role: 'listitem',
	},
	template: \`<ng-content />\`,
})
export class GrgFileListItem {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly file = input<File>();

	public readonly remove = output<void>();

	protected readonly _computedClass = computed(() =>
		hlm(
			'flex items-center gap-3 rounded-lg border bg-card p-3 text-card-foreground',
			this.userClass(),
		),
	);

	onRemove(): void {
		this.remove.emit();
	}
}

@Component({
	selector: 'grg-file-list',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		role: 'list',
	},
	template: \`<ng-content />\`,
})
export class GrgFileList {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('flex flex-col gap-2 mt-4', this.userClass()),
	);
}

@Component({
	selector: 'grg-file-name, [grgFileName]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	template: \`<ng-content />\`,
})
export class GrgFileName {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('text-sm font-medium truncate', this.userClass()),
	);
}

@Component({
	selector: 'button[grgFileRemove]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		type: 'button',
		'(click)': 'onClick($event)',
	},
	template: \`<ng-content />\`,
})
export class GrgFileRemove {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly remove = output<void>();

	protected readonly _computedClass = computed(() =>
		hlm(
			'shrink-0 rounded-md p-1 text-muted-foreground hover:bg-muted hover:text-foreground transition-colors',
			this.userClass(),
		),
	);

	onClick(event: Event): void {
		event.stopPropagation();
		this.remove.emit();
	}
}

@Pipe({
	name: 'fileSize',
	standalone: true,
})
export class FileSizePipe implements PipeTransform {
	transform(bytes: number | undefined): string {
		if (bytes === undefined || bytes === 0) return '0 Bytes';
		const k = 1024;
		const sizes = ['Bytes', 'KB', 'MB', 'GB'];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
	}
}

@Component({
	selector: 'grg-file-size, [grgFileSize]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	template: \`<ng-content />\`,
})
export class GrgFileSize {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('text-xs text-muted-foreground', this.userClass()),
	);
}

@Component({
	selector: 'grg-file-upload-description, [grgFileUploadDescription]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	template: \`<ng-content />\`,
})
export class GrgFileUploadDescription {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('text-xs text-muted-foreground', this.userClass()),
	);
}

export const fileUploadIconVariants = cva(
	'flex items-center justify-center rounded-full',
	{
		variants: {
			variant: {
				default: 'bg-muted text-muted-foreground',
				primary: 'bg-primary/10 text-primary',
			},
			size: {
				sm: 'h-10 w-10',
				md: 'h-12 w-12',
				lg: 'h-14 w-14',
			},
		},
		defaultVariants: {
			variant: 'default',
			size: 'md',
		},
	},
);

export type FileUploadIconVariants = VariantProps<typeof fileUploadIconVariants>;

@Component({
	selector: 'grg-file-upload-icon',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	template: \`<ng-content />\`,
})
export class GrgFileUploadIcon {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly variant = input<'default' | 'primary'>('default');
	public readonly size = input<'sm' | 'md' | 'lg'>('md');

	protected readonly _computedClass = computed(() =>
		hlm(
			fileUploadIconVariants({
				variant: this.variant(),
				size: this.size(),
			}),
			this.userClass(),
		),
	);
}

@Component({
	selector: 'grg-file-upload-label, [grgFileUploadLabel]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	template: \`<ng-content />\`,
})
export class GrgFileUploadLabel {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('text-sm font-medium text-foreground', this.userClass()),
	);
}

@Component({
	selector: 'grg-file-upload-trigger, [grgFileUploadTrigger]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
	template: \`<ng-content />\`,
})
export class GrgFileUploadTrigger {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm(
			'flex flex-col items-center justify-center gap-2 text-center cursor-pointer',
			this.userClass(),
		),
	);
}

export interface FileValidationError {
	file: File;
	type: 'size' | 'type';
	message: string;
}

export interface GrgFileUploadConfig {
	maxFileSize?: number; // in bytes
	maxFiles?: number;
	acceptedTypes?: string[]; // e.g., ['image/*', 'application/pdf']
}

export const fileUploadVariants = cva(
	'relative flex flex-col items-center justify-center rounded-lg border-2 border-dashed transition-colors',
	{
		variants: {
			state: {
				idle: 'border-muted-foreground/25 hover:border-muted-foreground/50 bg-muted/20',
				dragover: 'border-primary bg-primary/5',
				error: 'border-destructive bg-destructive/5',
				disabled: 'border-muted-foreground/10 bg-muted/10 cursor-not-allowed opacity-50',
			},
			size: {
				sm: 'p-4 min-h-[120px]',
				md: 'p-6 min-h-[160px]',
				lg: 'p-8 min-h-[200px]',
			},
		},
		defaultVariants: {
			state: 'idle',
			size: 'md',
		},
	},
);

export type FileUploadVariants = VariantProps<typeof fileUploadVariants>;
export type FileUploadSize = 'sm' | 'md' | 'lg';

@Component({
	selector: 'grg-file-upload',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'(dragover)': 'onDragOver($event)',
		'(dragleave)': 'onDragLeave($event)',
		'(drop)': 'onDrop($event)',
		'(click)': 'openFileDialog()',
	},
	template: \`
		<input
			#fileInput
			type="file"
			class="hidden"
			[accept]="acceptedTypesString()"
			[multiple]="multiple()"
			[disabled]="disabled()"
			(change)="onFileSelect($event)"
		/>
		<ng-content />
	\`,
})
export class GrgFileUpload {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly size = input<FileUploadSize>('md');
	public readonly disabled = input<boolean>(false);
	public readonly multiple = input<boolean>(true);
	public readonly maxFileSize = input<number>(10 * 1024 * 1024); // 10MB default
	public readonly maxFiles = input<number>(10);
	public readonly acceptedTypes = input<string[]>([]);

	public readonly files = model<File[]>([]);
	public readonly filesChange = output<File[]>();
	public readonly validationError = output<FileValidationError>();
	public readonly fileRemoved = output<File>();

	protected readonly fileInput = viewChild<ElementRef<HTMLInputElement>>('fileInput');
	protected readonly isDragOver = signal(false);
	protected readonly hasError = signal(false);

	protected readonly acceptedTypesString = computed(() => this.acceptedTypes().join(','));

	protected readonly _state = computed(() => {
		if (this.disabled()) return 'disabled';
		if (this.hasError()) return 'error';
		if (this.isDragOver()) return 'dragover';
		return 'idle';
	});

	protected readonly _computedClass = computed(() =>
		hlm(
			fileUploadVariants({
				state: this._state(),
				size: this.size(),
			}),
			this.userClass(),
		),
	);

	openFileDialog(): void {
		if (this.disabled()) return;
		this.fileInput()?.nativeElement.click();
	}

	onDragOver(event: DragEvent): void {
		event.preventDefault();
		event.stopPropagation();
		if (this.disabled()) return;
		this.isDragOver.set(true);
	}

	onDragLeave(event: DragEvent): void {
		event.preventDefault();
		event.stopPropagation();
		this.isDragOver.set(false);
	}

	onDrop(event: DragEvent): void {
		event.preventDefault();
		event.stopPropagation();
		this.isDragOver.set(false);

		if (this.disabled()) return;

		const droppedFiles = event.dataTransfer?.files;
		if (droppedFiles) {
			this.processFiles(Array.from(droppedFiles));
		}
	}

	onFileSelect(event: Event): void {
		const input = event.target as HTMLInputElement;
		if (input.files) {
			this.processFiles(Array.from(input.files));
		}
		// Reset input so same file can be selected again
		input.value = '';
	}

	private processFiles(newFiles: File[]): void {
		const currentFiles = this.files();
		const validFiles: File[] = [];

		for (const file of newFiles) {
			// Check max files limit
			if (currentFiles.length + validFiles.length >= this.maxFiles()) {
				break;
			}

			// Validate file size
			if (file.size > this.maxFileSize()) {
				this.hasError.set(true);
				this.validationError.emit({
					file,
					type: 'size',
					message: \`File "\${file.name}" exceeds maximum size of \${this.formatFileSize(this.maxFileSize())}\`,
				});
				setTimeout(() => this.hasError.set(false), 2000);
				continue;
			}

			// Validate file type
			if (!this.isValidFileType(file)) {
				this.hasError.set(true);
				this.validationError.emit({
					file,
					type: 'type',
					message: \`File "\${file.name}" is not an accepted file type\`,
				});
				setTimeout(() => this.hasError.set(false), 2000);
				continue;
			}

			// Check for duplicates
			const isDuplicate = currentFiles.some(
				(f) => f.name === file.name && f.size === file.size,
			);
			if (!isDuplicate) {
				validFiles.push(file);
			}
		}

		if (validFiles.length > 0) {
			const updatedFiles = [...currentFiles, ...validFiles];
			this.files.set(updatedFiles);
			this.filesChange.emit(updatedFiles);
		}
	}

	private isValidFileType(file: File): boolean {
		const accepted = this.acceptedTypes();
		if (accepted.length === 0) return true;

		return accepted.some((type) => {
			if (type.endsWith('/*')) {
				// Wildcard type like 'image/*'
				const category = type.slice(0, -2);
				return file.type.startsWith(category);
			}
			// Exact type match or extension
			if (type.startsWith('.')) {
				return file.name.toLowerCase().endsWith(type.toLowerCase());
			}
			return file.type === type;
		});
	}

	removeFile(file: File): void {
		const updatedFiles = this.files().filter((f) => f !== file);
		this.files.set(updatedFiles);
		this.filesChange.emit(updatedFiles);
		this.fileRemoved.emit(file);
	}

	clearFiles(): void {
		this.files.set([]);
		this.filesChange.emit([]);
	}

	private formatFileSize(bytes: number): string {
		if (bytes === 0) return '0 Bytes';
		const k = 1024;
		const sizes = ['Bytes', 'KB', 'MB', 'GB'];
		const i = Math.floor(Math.log(bytes) / Math.log(k));
		return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
	}
}

export const GrgFileUploadImports = [
	GrgFileUpload,
	GrgFileUploadTrigger,
	GrgFileUploadIcon,
	GrgFileUploadLabel,
	GrgFileUploadDescription,
	GrgFileList,
	GrgFileListItem,
	GrgFileIcon,
	GrgFileInfo,
	GrgFileName,
	GrgFileSize,
	GrgFileRemove,
	FileSizePipe,
] as const;`;

export const stepperSource = `/**
 * Stepper Component
 *
 * A flexible stepper component for Angular applications.
 *
 * Copy this file to your project and customize as needed.
 *
 * Dependencies:
 * - @spartan-ng/helm (UI components)
 * - class-variance-authority (styling variants)
 * - clsx (class utilities)
 *
 * Usage:
 * 1. Copy this file to your project (e.g., libs/ui/stepper/)
 * 2. Add path mapping in tsconfig.json:
 *    "@grg-kit/ui/stepper": ["./libs/ui/stepper/stepper.component.ts"]
 * 3. Import GrgStepperImports in your component
 */

import {
	Component,
	Directive,
	computed,
	contentChildren,
	inject,
	input,
	model,
	output,
	type Signal,
} from '@angular/core';
import { hlm } from '@spartan-ng/helm/utils';
import { type ClassValue } from 'clsx';
import { cva, type VariantProps } from 'class-variance-authority';
import { GrgStep } from './grg-step';

@Directive({
	selector: '[grgStepContent]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		role: 'tabpanel',
	},
})
export class GrgStepContent {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('mt-4', this.userClass()),
	);
}

@Directive({
	selector: '[grgStepDescription]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
	},
})
export class GrgStepDescription {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });

	protected readonly _computedClass = computed(() =>
		hlm('text-xs text-muted-foreground', this.userClass()),
	);
}

export const stepIndicatorVariants = cva(
	'flex items-center justify-center rounded-full border-2 font-medium transition-colors',
	{
		variants: {
			size: {
				sm: 'h-6 w-6 text-xs',
				md: 'h-8 w-8 text-sm',
				lg: 'h-10 w-10 text-base',
			},
			state: {
				inactive: 'border-muted-foreground/30 bg-background text-muted-foreground',
				active: 'border-primary bg-primary text-primary-foreground',
				completed: 'border-primary bg-primary text-primary-foreground',
			},
		},
		defaultVariants: {
			size: 'md',
			state: 'inactive',
		},
	},
);

export type StepIndicatorVariants = VariantProps<typeof stepIndicatorVariants>;
export type StepIndicatorState = 'inactive' | 'active' | 'completed';
export type StepIndicatorSize = 'sm' | 'md' | 'lg';

@Component({
	selector: 'grg-step-indicator',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'[attr.data-state]': 'state()',
	},
	template: \`<ng-content />\`,
})
export class GrgStepIndicator {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly size = input<StepIndicatorSize>('md');
	public readonly state = input<StepIndicatorState>('inactive');

	protected readonly _computedClass = computed(() =>
		hlm(stepIndicatorVariants({ size: this.size(), state: this.state() }), this.userClass()),
	);
}

export const stepLabelVariants = cva('font-medium transition-colors', {
	variants: {
		state: {
			inactive: 'text-muted-foreground',
			active: 'text-foreground',
			completed: 'text-foreground',
		},
		size: {
			sm: 'text-xs',
			md: 'text-sm',
			lg: 'text-base',
		},
	},
	defaultVariants: {
		state: 'inactive',
		size: 'md',
	},
});

export type StepLabelVariants = VariantProps<typeof stepLabelVariants>;

@Directive({
	selector: '[grgStepLabel]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'[attr.data-state]': 'state()',
	},
})
export class GrgStepLabel {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly state = input<'inactive' | 'active' | 'completed'>('inactive');
	public readonly size = input<'sm' | 'md' | 'lg'>('md');

	protected readonly _computedClass = computed(() =>
		hlm(stepLabelVariants({ state: this.state(), size: this.size() }), this.userClass()),
	);
}

export const stepSeparatorVariants = cva('transition-colors', {
	variants: {
		orientation: {
			horizontal: 'h-0.5 flex-1',
			vertical: 'w-0.5 min-h-8',
		},
		state: {
			inactive: 'bg-muted-foreground/30',
			active: 'bg-muted-foreground/30',
			completed: 'bg-primary',
		},
	},
	defaultVariants: {
		orientation: 'horizontal',
		state: 'inactive',
	},
});

export type StepSeparatorVariants = VariantProps<typeof stepSeparatorVariants>;

@Directive({
	selector: '[grgStepSeparator]',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		'[attr.data-state]': 'state()',
		'[attr.data-orientation]': 'orientation()',
	},
})
export class GrgStepSeparator {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly orientation = input<'horizontal' | 'vertical'>('horizontal');
	public readonly state = input<'inactive' | 'active' | 'completed'>('inactive');

	protected readonly _computedClass = computed(() =>
		hlm(
			stepSeparatorVariants({ orientation: this.orientation(), state: this.state() }),
			this.userClass(),
		),
	);
}

export const stepVariants = cva('flex gap-2', {
	variants: {
		orientation: {
			horizontal: 'flex-col items-center flex-1',
			vertical: 'flex-row items-start',
		},
	},
	defaultVariants: {
		orientation: 'horizontal',
	},
});

export type StepVariants = VariantProps<typeof stepVariants>;

@Component({
	selector: 'grg-step',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		role: 'tab',
		'[attr.aria-selected]': 'isActive()',
		'[attr.data-state]': 'state()',
		'[attr.data-orientation]': 'orientation()',
	},
	template: \`<ng-content />\`,
})
export class GrgStep {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly orientation = input<'horizontal' | 'vertical'>('horizontal');
	public readonly completed = model<boolean>(false);
	public readonly disabled = input<boolean>(false);
	public readonly optional = input<boolean>(false);
	public readonly label = input<string>('');
	public readonly description = input<string>('');
	public readonly icon = input<string>('');

	// Index will be set by parent stepper
	public readonly index = input<number>(0);
	public readonly isActive = input<boolean>(false);

	public readonly state = computed(() => {
		if (this.isActive()) return 'active';
		if (this.completed()) return 'completed';
		return 'inactive';
	});

	protected readonly _computedClass = computed(() =>
		hlm(stepVariants({ orientation: this.orientation() }), this.userClass()),
	);
}

export const stepperVariants = cva('flex w-full', {
	variants: {
		orientation: {
			horizontal: 'flex-row items-start',
			vertical: 'flex-col',
		},
	},
	defaultVariants: {
		orientation: 'horizontal',
	},
});

export type StepperVariants = VariantProps<typeof stepperVariants>;
export type StepperOrientation = 'horizontal' | 'vertical';

@Component({
	selector: 'grg-stepper',
	standalone: true,
	host: {
		'[class]': '_computedClass()',
		role: 'tablist',
		'[attr.aria-orientation]': 'orientation()',
	},
	template: \`<ng-content />\`,
})
export class GrgStepper {
	public readonly userClass = input<ClassValue>('', { alias: 'class' });
	public readonly orientation = input<StepperOrientation>('horizontal');
	public readonly currentStep = model<number>(0);
	public readonly linear = input<boolean>(false);

	public readonly stepChange = output<number>();

	public readonly steps: Signal<readonly GrgStep[]> = contentChildren(GrgStep);

	protected readonly _computedClass = computed(() =>
		hlm(stepperVariants({ orientation: this.orientation() }), this.userClass()),
	);

	public readonly totalSteps = computed(() => this.steps().length);
	public readonly isFirstStep = computed(() => this.currentStep() === 0);
	public readonly isLastStep = computed(() => this.currentStep() === this.totalSteps() - 1);

	goToStep(index: number): void {
		const steps = this.steps();
		if (index < 0 || index >= steps.length) return;

		if (this.linear()) {
			// In linear mode, can only go to next step if current is completed
			if (index > this.currentStep()) {
				const currentStepInstance = steps[this.currentStep()];
				if (!currentStepInstance?.completed()) return;
			}
		}

		this.currentStep.set(index);
		this.stepChange.emit(index);
	}

	next(): void {
		if (!this.isLastStep()) {
			this.goToStep(this.currentStep() + 1);
		}
	}

	previous(): void {
		if (!this.isFirstStep()) {
			this.goToStep(this.currentStep() - 1);
		}
	}

	reset(): void {
		this.currentStep.set(0);
		this.stepChange.emit(0);
	}
}

export const GrgStepperImports = [
	GrgStepper,
	GrgStep,
	GrgStepIndicator,
	GrgStepLabel,
	GrgStepDescription,
	GrgStepSeparator,
	GrgStepContent,
] as const;`;

// Map of blocks IDs to their source code
export const blockSourceMap: Record<string, string> = {
  'file-upload': fileUploadSource,
  'stepper': stepperSource,
};
